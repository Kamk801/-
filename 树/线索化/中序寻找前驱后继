//中序线索二叉树找后继  
#include<stdlib.h>
typedef struct tree{
	int data;
	TreeNode *lchild;   //三叉链表
	TreeNode* rchild;
	int ltag, rtag ; //1为线索   0为孩子
}TreeNode,*Tree;
TreeNode* pre = NULL;
TreeNode* firstnode(TreeNode* p) {
	while (p->ltag == 0) p = p->lchild;
	return p;
}

TreeNode*  SearchLchild(TreeNode* p) {
	if (p->rtag == 0) {
		return firstnode(p->rchild);
	}
	else {
		return p->lchild;
	}
}
//对中序线索化二叉树进行中序遍历
void inthread(Tree &T) {
	for (TreeNode* p = firstnode(T); p != NULL; p = SearchLchild(p)) {
		visit(p);
	}
}
void visit(TreeNode* p) {
	if (p->lchild == NULL) {
		p->lchild = pre;
		p->ltag = 1;
	}
	if (pre->rchild == NULL && pre!=NULL) {
		pre->rchild = p;
		pre->rtag = 1;
	}
	pre = p;
}







//中序线索二叉树找前驱
TreeNode* lastnode(TreeNode* p) {
	while (p->rtag == 0) p = p->rchild;
	return p;
}

TreeNode* PreLchild(TreeNode* p) {
	if (p->ltag == 0) {
		return lastnode(p->lchild);
	}
	else {
		return p->lchild;
	}
}
//对中序线索化二叉树进行逆中序遍历
void reverse(Tree& T) {
	for (TreeNode* p = lastnode(T); p != NULL; p = PreLchild(p)) {
		visit(p);
	}
}
