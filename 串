//串
#include<stdio.h>
#include<stdlib.h>
#define MaxLEN 255
//静态分配
typedef struct {
	char ch[MaxLEN];
	int length;
}SString;
//动态分配
typedef struct {
	char* ch;
	int length;  
}Hstring;
//链式存储
typedef struct {        //存储密度低
	char data;          //占1B
	StringNode* next;   //占4B
}StringNode,* String;
//改进版
typedef struct {        //存储密度低
	char data[4];          //占1B
	StringNode* next;   //占4B
}StringNode, * String;
int StrLength(SString S) {    //求串长
	return S.length;
}
//求子串
bool  SubString(SString &Sub,SString S,int pos,int len) {   //用Sub返回串的第pos个字符起长度为len的子串
	if (pos+len-1>S.length) {
		return false;
	}
	for (int i = pos;i<pos+len; i++) {
		Sub.ch[i-pos+1] = S.ch[i];
	}
	Sub.length = len;
	return true;
}
int StrCompare(SString S, SString T) {  //比较操作。若S>T,则返回值>0;若S=T,则返回值=0；若S<T,则返回值<0
	for (int i = 1; i <= S.length && i <=T.length; i++) {
		if (S.ch[i] != T.ch[i]) {
			return S.ch[i] - T.ch[i];
		}
	}
	return T.length - S.length;
}
//定位操作 。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置，否则函数值为0.
int Index(SString S, SString T) {
	SString sub;
	sub.length = 0;
	int i = 1;
	int k = T.length;
	while (i+k-1 <= S.length) {
		SubString(sub, S, i, k);
		int temp=StrCompare(sub, T);
		if (temp == 0) {
			return i;
		}
		++i;
	}
	return 0;
}
void main() {
	Hstring hs;
	hs.ch = (char*)malloc(MaxLEN * sizeof(char));
	hs.length = 0;
}
